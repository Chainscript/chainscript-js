#!/usr/bin/env node
/*eslint-disable */

var path = require('path');
var commander = require('commander');
var Bitcore = require('bitcore');
var Chainscript = require(path.resolve(__dirname, '../lib'));

function parseBool(v) {
  return v === 'true' || v === '1' ? true : false;
}

commander
  .version('0.9.0')
  .usage('[options] [script | uuid]')
  .option('-u, --update <updates>', 'Update script')
  .option('-s, --snapshot', 'Snapshot script')
  .option('-n, --notarize', 'Notarize script')
  .option('-e, --email <address>', 'Email')
  .option('-S, --sign <wif>', 'Sign the digest')
  .option(
    '--command-auditing <bool>',
    'Enable or disable command auditing',
    parseBool
  )
  .option(
    '--revision-auditing <bool>',
    'Enable or disable revision auditing',
    parseBool
  )
  .option('-I, --input-format <json | list>', 'Set input format')
  .option('-O, --output-format <json | list>', 'Set output format')
  .option('-K, --gen-key', 'Generate and print a key pair and address')
  .option('-T, --testnet', 'Use testnet')
  .parse(process.argv);

function handleOutput(output) {
  var str = '';

  switch (commander.outputFormat) {
  case 'list':
    var target = output.body && output.body.content ?
      output.body.content :
      output;
    if (typeof target === 'object' && target) {
      Object.keys(target).forEach(function(key) {
        str += key + '\t' + target[key] + '\n';
      });
    } else {
      str = target + '\n';
    }
    break;
  default:
    str = JSON.stringify(output, null, '\t') + '\n';
  }
  process.stdout.write(str);
}

function run(cs) {

  function exec() {
    function postfix() {
      if (commander.notarize) {
        cs.notarize();
      }

      if (commander.email) {
        cs.email(commander.email);
      }

      cs
        .run()
        .then(function() {
          handleOutput(cs.toJSON());
          process.exit(0);
        }).fail(function(err) {
          process.stderr.write(err.message + '\n');
          process.exit(1);
        });
    }

    if (typeof commander.commandAuditing !== 'undefined') {
      cs.script.x_chainscript.command_auditing = commander.commandAuditing;
    }

    if (typeof commander.revisionAuditing !== 'undefined') {
      cs.script.x_chainscript.revision_auditing = commander.revisionAuditing;
    }

    if (commander.update) {
      try {
        cs.update(JSON.parse(commander.update));
      } catch(e) {
        cs.update(commander.update);
      }
    }

    if (commander.snapshot) {
      cs.script.x_chainscript = cs.script.x_chainscript || {};
      cs.script.x_chainscript.snapshots_enabled = true;
      cs.snapshot();
    }

    if (commander.sign) {
      cs
        .run()
        .then(function() {
          cs.sign(commander.sign);
          postfix();
        }).fail(function(err) {
          process.stderr.write(err.message + '\n');
          process.exit(1);
        });

    } else {
      postfix();
    }
  }

  if (typeof cs.script.x_chainscript === 'undefined') {
    cs
      .run()
      .then(exec).fail(function(err) {
        process.stderr.write(err.message + '\n');
        process.exit(1);
      });
  } else {
    exec();
  }
}

function handleInput(input) {
  if (input.match(/^chainscript:/)) {
    Chainscript.load(input)
      .then(run)
      .fail(function(err) {
        process.stderr.write(err.message + '\n');
        process.exit(1);
      });
  } else {
    var json;

    switch (commander.inputFormat) {
    case 'list':
      var lines = input.split('\n');
      json = {content: {}};
      lines.forEach(function(line) {
        var parts = line.split(/\s+/);
        if (parts.length > 1) {
          json.content[parts[0]] = line
            .substr(parts[0].length)
            .replace(/^\s+/, '');
        }
      });
    break;
    default:
      try {
        json = JSON.parse(input);
      } catch (e) {
        json = {content: input};
      }
    }

    run(new Chainscript(json));
  }
}

if (commander.genKey) {
  var privateKey = new Bitcore.PrivateKey();
  var publicKey = privateKey.toPublicKey();

  if (commander.testnet) {
    var address = publicKey.toAddress(Bitcore.Networks.testnet);
  } else {
    address = publicKey.toAddress(Bitcore.Networks.livenet);
  }

  handleOutput({
    private: privateKey.toWIF(),
    public: publicKey.toString(),
    address: address.toString()
  });

  process.exit(0);
}

if (commander.args.length > 1) {
  commander.outputHelp();
  process.exit(1);
}

if (commander.args.length === 0) {
  process.stdin.setEncoding('utf8');

  var input = '';

  process.stdin.on('readable', function() {
    var chunk = process.stdin.read();
    if (chunk !== null) {
      input += chunk.toString();
    }
  });

  process.stdin.on('end', function() {
    input = input.replace(/\n$/, '');

    if (input.length) {
      handleInput(input);
    } else {
      commander.outputHelp();
      process.exit(1);
    }
  });
} else {
  handleInput(commander.args[0]);
}
