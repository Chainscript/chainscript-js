#!/usr/bin/env node
/*eslint-disable */

var path = require('path');
var commander = require('commander');
var objectPath = require('object-path');
var Bitcore = require('bitcore');
var mergeDeep = require('merge-deep');
var readPackageSync = require(path.resolve(__dirname, '../lib/utils/readPackageSync'));
var Chainscript = require(path.resolve(__dirname, '../lib'));

function collectUpdates(val, memo) {
  memo.push(val);
  return memo;
}

function parseBool(v) {
  return v === 'true' || v === '1' ? true : false;
}

commander
  .version(readPackageSync('version'))
  .usage('[options] [script | uuid]')
  .option('-u, --update <updates>', 'Update script', collectUpdates, [])
  .option('-s, --snapshot', 'Snapshot script')
  .option('-n, --notarize', 'Notarize script')
  .option('-e, --email <address>', 'Email')
  .option('--subject <subject>', 'Email subject')
  .option('-S, --sign <wif>', 'Sign the digest')
  .option(
    '--command-auditing <bool>',
    'Enable or disable command auditing',
    parseBool
  )
  .option(
    '--revision-auditing <bool>',
    'Enable or disable revision auditing',
    parseBool
  )
  .option('-K, --gen-key', 'Generate and print a key pair and address')
  .option('-T, --testnet', 'Use testnet')
  .option(
    '--execute-url <url>',
    'Set execute url'
  )
  .option(
    '--snapshots-url <url>',
    'Set snapshots url'
  )
  .parse(process.argv);

function handleInput(input) {
  if (input.match(/^chainscript:/)) {
    Chainscript.load(input)
      .then(run)
      .fail(handleError);
  } else {
    var json;

    try {
      json = JSON.parse(input);
    } catch (e) {
      json = {content: input};
    }

    run(new Chainscript(json));
  }
}

function handleOutput(output) {
  process.stdout.write(JSON.stringify(output, null, '\t') + '\n');
  process.exit(0);
}

function handleError(err) {
  process.stderr.write(err.message + '\n');
  process.exit(1);
}

function run(cs) {

  if (typeof commander.executeUrl !== 'undefined') {
    Chainscript.EXECUTE_URL = commander.executeUrl;
  }

  if (typeof commander.snapshotsUrl !== 'undefined') {
    Chainscript.SNAPSHOTS_URL = commander.snapshotsUrl;
  }

  function exec() {
    if (typeof commander.commandAuditing !== 'undefined') {
      cs.set('x_chainscript.command_auditing', commander.commandAuditing);
    }

    if (typeof commander.revisionAuditing !== 'undefined') {
      cs.set('x_chainscript.revision_auditing', commander.revisionAuditing);
    }

    if (commander.update.length > 0) {
      var updates;

      commander.update.forEach(function(u) {
        try {
          u = JSON.parse(u);
        } catch(e) { }
        if (typeof updates === 'object' && updates &&
            typeof u === 'object' && u) {
          updates = mergeDeep(updates, u);
        } else {
          updates = u;
        }
      });

      cs.update(updates);
    }

    if (commander.sign) {
      cs.sign(commander.sign);
    }

    if (commander.snapshot) {
      cs.snapshot();
    }

    if (commander.notarize) {
      cs.notarize();
    }

    if (commander.email) {
      cs.email(commander.email, commander.subject);
    }

    cs
      .run()
      .then(function() {
        handleOutput(cs.toJSON());
      }).fail(handleError);
  }

  if (typeof cs.script.x_chainscript === 'undefined') {
    cs
      .run()
      .then(exec)
      .fail(handleError);
  } else {
    exec();
  }
}

if (commander.genKey) {
  var privateKey = new Bitcore.PrivateKey();
  var publicKey = privateKey.toPublicKey();

  if (commander.testnet) {
    var address = publicKey.toAddress(Bitcore.Networks.testnet);
  } else {
    address = publicKey.toAddress(Bitcore.Networks.livenet);
  }

  handleOutput({
    private: privateKey.toWIF(),
    public: publicKey.toString(),
    address: address.toString()
  });
}

if (commander.args.length > 1) {
  commander.outputHelp();
  process.exit(1);
}

if (commander.args.length === 0) {
  process.stdin.setEncoding('utf8');

  var input = '';

  process.stdin.on('readable', function() {
    var chunk = process.stdin.read();

    if (chunk !== null) {
      input += chunk.toString();
    }
  });

  process.stdin.on('end', function() {
    input = input.replace(/\n$/, '');

    if (input.length) {
      handleInput(input);
    } else {
      commander.outputHelp();
      process.exit(1);
    }
  });
} else {
  handleInput(commander.args[0]);
}
