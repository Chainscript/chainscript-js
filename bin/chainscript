#!/usr/bin/env node
/*eslint-disable */

var path = require('path');
var commander = require('commander');
var Bitcore = require('bitcore');
var Chainscript = require(path.resolve(__dirname, '../lib'));

function run(cs) {

  function exec() {
    function postfix() {
      if (commander.notarize) {
        cs.notarize();
      }

      if (commander.email) {
        cs.email(commander.email);
      }

      cs
        .run()
        .then(function() {
          process.stdout.write(JSON.stringify(cs.toJSON(), null, '\t') + '\n');
          process.exit(0);
        }).fail(function(err) {
          process.stderr.write(err.message + '\n');
          process.exit(1);
        });
    }

    if (typeof commander.commandAuditing !== 'undefined') {
      cs.script.x_chainscript.command_auditing = commander.commandAuditing;
    }

    if (typeof commander.revisionAuditing !== 'undefined') {
      cs.script.x_chainscript.revision_auditing = commander.revisionAuditing;
    }

    if (commander.update) {
      try {
        cs.update(JSON.parse(commander.update));
      } catch(e) {
        cs.update(commander.update);
      }
    }

    if (commander.snapshot) {
      cs.script.x_chainscript = cs.script.x_chainscript || {};
      cs.script.x_chainscript.snapshots_enabled = true;
      cs.snapshot();
    }

    if (commander.sign) {
      cs
        .run()
        .then(function() {
          cs.sign(commander.sign);
          postfix();
        }).fail(function(err) {
          process.stderr.write(err.message + '\n');
          process.exit(1);
        });

    } else {
      postfix();
    }
  }

  if (typeof cs.script.x_chainscript === 'undefined') {
    cs
      .run()
      .then(exec).fail(function(err) {
        process.stderr.write(err.message + '\n');
        process.exit(1);
      });
  } else {
    exec();
  }
}

function parseBool(v) {
  return v === 'true' || v === '1' ? true : false;
}

commander
  .version('0.9.0')
  .usage('[options] <script | uuid>')
  .option('-u, --update <string>', 'Update script')
  .option('-s, --snapshot', 'Snapshot script')
  .option('-n, --notarize', 'Notarize script')
  .option('-e, --email <string>', 'Email')
  .option('-S, --sign <string>', 'Sign the digest')
  .option(
    '--command-auditing <bool>',
    'Enable or disable command auditing',
    parseBool
  )
  .option(
    '--revision-auditing <bool>',
    'Enable or disable revision auditing',
    parseBool
  )
  .option('-K, --gen-key', 'Generate and print a key pair and address')
  .option('-T, --testnet', 'Use testnet')
  .parse(process.argv);

if (commander.genKey) {
  var privateKey = new Bitcore.PrivateKey();
  var publicKey = privateKey.toPublicKey();

  if (commander.testnet) {
    var address = publicKey.toAddress(Bitcore.Networks.testnet);
  } else {
    address = publicKey.toAddress(Bitcore.Networks.livenet);
  }

  process.stdout.write(JSON.stringify({
    private: privateKey.toWIF(),
    public: publicKey.toString(),
    address: address.toString()
  }, null, '\t') + '\n');

  process.exit(0);
}

if (!commander.args.length) {
  commander.outputHelp();
  process.exit(1);
}

if (commander.args[0].match(/^chainscript:/)) {
  Chainscript.load(commander.args[0])
    .then(run)
    .fail(function(err) {
      process.stderr.write(err.message + '\n');
      process.exit(1);
    });
} else {
  try {
    run (new Chainscript(JSON.parse(commander.args[0])));
  } catch (e) {
    run (new Chainscript({content: commander.args[0]}));
  }
}
