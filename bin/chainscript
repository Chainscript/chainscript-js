#!/usr/bin/env node
/*eslint-disable */

var path = require('path');
var commander = require('commander');
var objectPath = require('object-path');
var Bitcore = require('bitcore');
var mergeDeep = require('merge-deep');
var readPackageSync = require(path.resolve(__dirname, '../lib/utils/readPackageSync'));
var Chainscript = require(path.resolve(__dirname, '../lib'));

function collectUpdates(val, memo) {
  memo.push(val);
  return memo;
}

function collectUpdateKeys(val, memo) {
  memo.push(val);
  return memo;
}

function parseBool(v) {
  return v === 'true' || v === '1' ? true : false;
}

commander
  .version(readPackageSync('version'))
  .usage('[options] [script | uuid]')
  .option('-u, --update <updates>', 'Update script', collectUpdates, [])
  .option(
    '-U, --update-key <key:value>',
    'Update specific content key',
    collectUpdateKeys, []
  )
  .option('-s, --snapshot', 'Snapshot script')
  .option('-n, --notarize', 'Notarize script')
  .option('-e, --email <address>', 'Email')
  .option('--subject <subject>', 'Email subject')
  .option('-g, --get <path>', 'Output value at path')
  .option('-S, --sign <wif>', 'Sign the digest')
  .option(
    '--command-auditing <bool>',
    'Enable or disable command auditing',
    parseBool
  )
  .option(
    '--revision-auditing <bool>',
    'Enable or disable revision auditing',
    parseBool
  )
  .option('-K, --gen-key', 'Generate and print a key pair and address')
  .option('-T, --testnet', 'Use testnet')
  .option(
    '--execute-url <url>',
    'Set execute url'
  )
  .option(
    '--snapshots-url <url>',
    'Set snapshots url'
  )
  .parse(process.argv);

function handleInput(input) {
  if (input.match(/^chainscript:/)) {
    Chainscript.load(input)
      .then(run)
      .fail(handleError);
  } else {
    var json;

    try {
      json = JSON.parse(input);
    } catch (e) {
      json = {content: input};
    }

    run(new Chainscript(json));
  }
}

function handleOutput(output) {
  if (commander.get) {
    output = objectPath.get(output, commander.get);
  }

  if (typeof output === 'object' && output) {
    var str = JSON.stringify(output, null, '\t') + '\n';
  } else {
    str = output + '\n';
  }

  process.stdout.write(str, function() {
    process.exit(0);
  });
}

function handleError(err) {
  process.stderr.write(err.message + '\n', function() {
    process.exit(1);
  });
}

function run(cs) {

  // Stage 1: settings, updates

  function stage1() {
    if (typeof commander.commandAuditing !== 'undefined') {
      cs.set('x_chainscript.command_auditing', commander.commandAuditing);
    }

    if (typeof commander.revisionAuditing !== 'undefined') {
      cs.set('x_chainscript.revision_auditing', commander.revisionAuditing);
    }

    if (commander.update.length > 0 || commander.updateKey.length > 0) {
      var updates;

      commander.update.forEach(function(u) {
        try {
          u = JSON.parse(u);
        } catch(e) { }

        if (typeof updates === 'object' && updates &&
            typeof u === 'object' && u) {
          updates = mergeDeep(updates, u);
        } else {
          updates = u;
        }
      });

      commander.updateKey.forEach(function(u) {
        var parts = u.split(':');
        var key = parts[0];
        var raw = parts.slice(1).join(':');
        var value = {};

        try {
          objectPath.set(value, key, JSON.parse(raw));
        } catch(e) {
          objectPath.set(value, key, raw);
        }

        updates = mergeDeep(updates, value);
      });

      cs
        .update(updates)
        .run()
        .then(stage2)
        .fail(handleError);
    } else {
      stage2();
    }
  }

  // Stage 2: sign, snapshot, notarize, email

  function stage2() {
    if (commander.sign) {
      cs.sign(commander.sign);
    }

    if (commander.snapshot) {
      cs.snapshot();
    }

    if (commander.notarize) {
      cs.notarize();
    }

    if (commander.email) {
      cs.email(commander.email, commander.subject);
    }

    cs
      .run()
      .then(function() {
        handleOutput(cs.toJSON());
      }).fail(handleError);
  }

  if (typeof commander.executeUrl !== 'undefined') {
    Chainscript.EXECUTE_URL = commander.executeUrl;
  }

  if (typeof commander.snapshotsUrl !== 'undefined') {
    Chainscript.SNAPSHOTS_URL = commander.snapshotsUrl;
  }

  // Dry run first if no x_chainscript

  if (typeof cs.script.x_chainscript === 'undefined') {
    cs
      .run()
      .then(stage1)
      .fail(handleError);
  } else {
    stage1();
  }
}

if (commander.genKey) {
  var privateKey = new Bitcore.PrivateKey();
  var publicKey = privateKey.toPublicKey();

  if (commander.testnet) {
    var address = publicKey.toAddress(Bitcore.Networks.testnet);
  } else {
    address = publicKey.toAddress(Bitcore.Networks.livenet);
  }

  handleOutput({
    private: privateKey.toWIF(),
    public: publicKey.toString(),
    address: address.toString()
  });
}

if (commander.args.length > 1) {
  commander.outputHelp();
  process.exit(1);
}

if (commander.args.length === 0) {
  process.stdin.setEncoding('utf8');

  var input = '';

  process.stdin.on('readable', function() {
    var chunk = process.stdin.read();

    if (chunk !== null) {
      input += chunk.toString();
    }
  });

  process.stdin.on('end', function() {
    input = input.replace(/\n$/, '');

    if (input.length) {
      handleInput(input);
    } else {
      commander.outputHelp();
      process.exit(1);
    }
  });
} else {
  handleInput(commander.args[0]);
}
